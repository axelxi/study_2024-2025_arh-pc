---
## Front matter
title: "Лабораторная работа №9"
subtitle: "Понятие подпрограммы. Отладчик GDB."
author: "Акунаева Антонина Эрдниевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями.

# Задание

Научиться реализовывать подпрограммы в NASM.  
Научиться пользоваться отладчиком в GBD.  
Познакомиться с GBD и его возможностями.  


# Выполнение лабораторной работы

## Реализация подпрограмм в NASM

3.1.1. Создайте каталог для программам лабораторной работы №9, перейдите в него и создайте файл lab09-1.asm.

![Использование команд mkdir и touch](image/1.jpg){#fig:fig1 width=80%}

Создадим каталог lab09 в рабочем каталоге при помощи mkdir, перейдём в него с cd. В новом каталоге создадим NASM-файл lab09-1.asm при помощи touch.

3.1.2. Внимательно изучите текст программы (Листинг 9.1). Введите в файл lab09-1.asm текст программы из листинга 9.1. Создайте исполняемый файл и проверьте его работу.

![Mcedit: листинг 9.1 в файле lab09-1.asm](image/2.jpg){#fig:fig2 width=80%}

![Создание и запуск исполняемого файла lab09-1](image/3.jpg){#fig:fig3 width=80%}

Изучим текст листинга 9.1 - в нём описан текст программы для вычисления выражения 2x+7 при введённом x с использованием подпрограммы. Скопируем текст из листинга 9.1 в файл lab9-1.asm в текстовом редакторе mcedit, создадим исполняемый файл и запустим его. Программа работает корректно.

Измените текст программы, добавив подпрограмму _subcalcul в подпрограмму _calcul, для вычисления выражения f(g(x)), где x вводится с клавиатуры, f(x) = 2x + 7, g(x) = 3x − 1. Т.е. x передается в подпрограмму _calcul из нее в подпрограмму _subcalcul, где вычисляется выражение g(x), результат возвращается в _calcul и вычисляется выражение f(g(x)). Результат возвращается в основную программу для вывода результата на экран.

![Mcedit: файл lab09-1.asm: добавление _subcalcul](image/4.jpg){#fig:fig4 width=80%}

Впишем подпрограмму подпрограммы _subcalcul в _calcul для выражения x = 3x - 1, которое будет использоваться в f(x) = 2x + 7. Также впишем перед умножением на 2 строку-вызов подпрограммы call _subcalcul.

![Создание и запуск исполняемого файла lab09-1: добавление _subcalcul](image/5.jpg){#fig:fig5 width=80%}

Создадим и запустим новый исполняемый файл и проверим работу. Программа выполняетяс корректно.
 
## Отладка программам с помощью GDB

3.2.1. Создайте файл lab09-2.asm с текстом программы из Листинга 9.2. (Программа печати сообщения Hello world!).

![Создание lab09-2.asm при помощи touch](image/6.jpg){#fig:fig6 width=80%}

![Mcedit: листинг 9.2 в файле lab09-2.asm](image/7.jpg){#fig:fig7 width=80%}

Создадим при помощи touch файл lab09-2.asm в текущей директории и впишем туда текст листинга 9.2 в mcedit.

Получите исполняемый файл. Для работы с GDB в исполняемый файл необходимо добавить отладочную информацию, для этого трансляцию программ необходимо проводить с ключом ‘-g’.

![Создание и запуск исполняемого файла lab09-2: добавление -g](image/8.jpg){#fig:fig8 width=80%}

Оттранслируем объектный файл и создадим исполняемый с использованием ключей -l и названия файла для листинга и -g для добавления отладочной информации.

Загрузите исполняемый файл в отладчик gdb.

![Запуск lab09-2 в отладчике GDB](image/9.jpg){#fig:fig9 width=80%}

Введём gdb lab09-2 для открытия файла в отладчике GBD. Получаем приветственную ознакомительную информацию об отладчике.

Проверьте работу программы, запустив ее в оболочке GDB с помощью команды run (сокращённо r).

![GDB: запуск программы](image/10.jpg){#fig:fig10 width=80%}

Введём команду run. Согласимся на использование debuginfod в этой сессии, чтобы продолжить. Программа выполняется корректно и выводит надпись "Hello, world!" на экран.

Для более подробного анализа программы установите брейкпоинт на метку _start, с которой начинается выполнение любой ассемблерной программы, и запустите её.

![GDB: установка Breakpoint](image/11.jpg){#fig:fig11 width=80%}

Установим брейкпоинт в начале программы, в секции _start, чтобы подробно рассмотреть её. Запустим и получим обозначение брейкпоинта на указанной метке (строке) и ожидания последующих действий.

Посмотрите дисассимилированный код программы с помощью команды disassemble начиная с метки _start.

![GDB: дисассимилированный код программы](image/12.jpg){#fig:fig12 width=80%}

Введём команду disassemble для начальной метки _start. Получим дисассимилированный (т.е. переведённый на машинный язык) код нашей программы построчно.

Переключитесь на отображение команд с Intel’овским синтаксисом, введя команду set disassembly-flavor intel.

![GDB: дисассимилированный код на Intel](image/13.jpg){#fig:fig13 width=80%}

Установим синтаксис, свойственный процессорам Intel, командой set
disassembly-flavor intel. Повторно ведём команду disassemble для начальной метки _start. Получим дисассимилированный код, но уже изменённый под синтаксис Intel.

Перечислите различия отображения синтаксиса машинных команд в режимах ATT и Intel. Включите режим псевдографики для более удобного анализа программы.

![GDB: псевдографика](image/14.jpg){#fig:fig14 width=80%}

Синтаксис машинных команд ATT и Intel различается в:

1. Порядке операндов. В ATT сначала указывается исходный, а затем результирующий, в Intel - наоборот.

2. Обозначение регистров. В ATT перед регистрами указывается символ "%", в Intel может быть "E" или "R".

3. Обозначение адресов. В ATT адреса указываются с использованием скобок и с "$", в Intel - без.

## Добавление точек останова

3.3.1. На предыдущих шагах была установлена точка останова по имени метки (_start). Проверьте это с помощью команды info breakpoints (кратко i b).

![Breakpoint check](image/15.jpg){#fig:fig15 width=80%}

Проверим наличие установленной ранее брейкпоинта при помощи info breakpoints в терминале. Точка действительно существует на строке 9 в lab09-2.

Установим еще одну точку останова по адресу инструкции. Адрес инструкции можно увидеть в средней части экрана в левом столбце соответствующей инструкции. Определите адрес предпоследней инструкции (mov ebx,0x0) и установите точку останова.

![Установка Breakpoint в GBD](image/16.jpg){#fig:fig16 width=80%}

Найдём предпоследнюю инструкцию программы mov ebx,0x0 с адресом 0x8049031. Назначим брейкпоинт на эту строку через команду break *0x8049031 и проверяем в средней полосе отладчика. Точка успешно установлена.

Посмотрите информацию о всех установленных точках останова.

![GBD: все Breakpoint](image/17.jpg){#fig:fig17 width=80%}

Введём сокращённую команду i b в терминал gbd и получим список из двух устанвленных нами брейкпоинтов.

## Работа с данными программы в GDB

3.4.1. Выполните 5 инструкций с помощью команды stepi (или si) и проследите за изменением значений регистров. Значения каких регистров изменяются?

![GBD: использование si](image/18.jpg){#fig:fig18 width=80%}

Введём пять раз команду si (шаг). Отмечаются активные строки и регистры записываются в верхней части терминала. Изменяются регистры ebx, ecx, edx, eax, eip.

Посмотреть содержимое регистров также можно с помощью команды info registers.

![GBD: использование info registers](image/19.jpg){#fig:fig19 width=80%}

Введём команду info registers и получим список регистров и их содержимое в нижней части терминала.

Посмотрите значение переменной msg1 по имени.

![GBD: просмотр значения переменной по имени](image/20.jpg){#fig:fig20 width=80%}

Введём команду x/1sb &msg1 и получим информацию о значении переменной msg1, обратившись к ней по её имени msg1.

Посмотрите значение переменной msg2 по адресу. Посмотрите инструкцию mov ecx,msg2 которая записывает в регистр ecx адрес перемененной msg2.

![GBD: просмотр значения переменной по адресу](image/21.jpg){#fig:fig21 width=80%}

Введём команду x/1sb 0х804а008 и получим информацию о значении переменной msg2, обратившись к ней по её адресу, который можно найти в списке по дизассемблированной инструкции.

Измените первый символ переменной msg1.

![GBD: изменение переменной msg1](image/22.jpg){#fig:fig22 width=80%}



Замените любой символ во второй переменной msg2.

![GBD: изменение переменной msg2](image/23.jpg){#fig:fig23 width=80%}



Выведите в различных форматах (в шестнадцатеричном формате, в двоичном формате и в символьном виде) значение регистра edx.

![GBD: ](image/24.jpg){#fig:fig24 width=80%}



С помощью команды set измените значение регистра ebx.



Объясните разницу вывода команд p/s $ebx.



Завершите выполнение программы с помощью команды continue (сокращенно c) или stepi (сокращенно si) и выйдите из GDB с помощью команды quit (сокращенно q).



## Обработка аргументов командной строки в GDB

3.5.1. Скопируйте файл lab8-2.asm, созданный при выполнении лабораторной работы №8, с программой выводящей на экран аргументы командной строки (Листинг 8.2) в файл с именем lab09-3.asm.

Создайте исполняемый файл.

Загрузите исполняемый файл в отладчик, указав аргументы.

Исследуем расположение аргументов командной строки в стеке после запуска программы с помощью gdb. Для начала установим точку останова перед первой инструкцией в программе и запустим ее.

Посмотрите остальные позиции стека – по адесу [esp+4] располагается адрес в памяти, где находиться имя программы, по адесу [esp+8] храниться адрес первого аргумента, по адресу [esp+12] – второго и т.д.

Объясните, почему шаг изменения адреса равен 4 ([esp+4], [esp+8], [esp+12] и т.д.).

# Описание результатов выполнения заданий для самостоятельной работы

4.1. Преобразуйте программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции f(x) как подпрограмму.

Вариант 13. f(x)=12x-7

![Создание lab8-4.asm при помощи touch](image/16.jpg){#fig:fig16 width=80%}

![Mcedit: lab8-4.asm](image/17.jpg){#fig:fig17 width=80%}

Создадим NASM-файл lab8-4.asm при помощи touch в текущей директории. Запишем в него текст программы, соответствующей условию со значениями и функцией из варианта 13.

![Создание и запуск исполняемого файла lab8-4](image/18.jpg){#fig:fig18 width=80%}

Оттранслируем объектный файл и создадим исполняемый, запустим его. В результате выводится сумма значений функции f(x)=12x-7 при разных введённых аргументах.

4.2. В листинге 9.3 приведена программа вычисления выражения (3 + 2) ∗ 4 + 5. При запуске данная программа дает неверный результат. Проверьте это. С помощью отладчика GDB, анализируя изменения значений регистров, определите ошибку и исправьте ее.

# Выводы

Я приобрела навыки написания программ с использованием подпрограмм и познакомилась с методами отладки при помощи GDB и его основными возможностями.
